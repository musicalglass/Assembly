In the previous video, as you may recall, I used 828 here. 828 and then when I added the SYS call it created an error. Okay so why was I using 828? Well because the book that I'm drawing from Commodore 64 Assembly Language Programming from Hayden books used 828 and as I have demonstrated it worked just fine until I added the SYS call in there. Right. Okay, now I had erroneously said that this was the beginning of user memory that is not quite correct if we go over here to the C64 programmer reference manual which you can find online in a variety of places is... uh 
Here is the map of the memory locations in the Commodore 64. Here we have 1024 to 2039 screen memory which we'll be using in a moment. But here's the bit we're interested in here. It says start of memory to memory used by the operating system up to 1023 so you could see where if I used 828 it could actually create a conflict with the operating system. So if we go down here it says THIS is YOUR memory from 2048 to 4959. So you have an ample memory space available here to play around with. And when I used an arbitrary value of Hexidecimal 1000, it fell well within the parameters of this. So just taking that on board for a moment. 2048. If that's the start of memory, okay. I'm going to just put 2048 here, and then that makes this SYS call obsolete so I'm going to add a new one generate SYS call 2048 would be 800 in Hexadecimal. 
Okay. so now if I were to launch that, it gives me an error here: Memory Overwrite but it's going to go ahead and launch the program anyways and give me another error. Okay so, 
reason for that see if I hold my mouse over here it tells you the value in Binary, Octal, Decimal and Hexadecimal and...
Let me do that one more time 
In Decimal it's 2049. So you could see where if I'm using 2048 here where there could be a a memory conflict.
Right. Here it says Memory Overwrite Detected. So fortunately CBM Studio has the foresight to tell us what the error is, instead of just the generic error from the C64. Okay, so therefore, if this is overlapping a little let's clean that up. Let me, if just count the bytes here one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bytes are being used here so then in theory if I added 16 to this value which would make it 2064 and then let me reset my SYS call again 2064 is oh, 810 in Hexadecimal. So that means I could also go $810 here and it's the same as 2064 here, you see? The SYS call tells you what the value is there but... 
264 Good enough.
So now if I Launch that we are free and clear and there's no conflict with the SYS call and my declared start of memory.