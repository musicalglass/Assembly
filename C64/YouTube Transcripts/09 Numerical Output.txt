In the book that I am drawing a lot of my Assembly Language programming tutorials from the Commodore 64 Assembly Language Programming book, a lot of the examples will print a value to the screen in the form of a character instead of printing the value. Let me just start a new (BASIC) file here. I'm going to call this numericalOutput.bas

oops oh not U O T It's O U T.

And we'll start at 2066. We'll leave a couple spaces at the top.

Add our little cheat code.

Good to go. Alright, so as you're familiar in the past I could load a value whoops! Need a space. Load a value and then print it to the screen 1024.

Return from subroutine to BASIC. Pretty obvious what that does by now.

Okay, there. I input a value of 0 and it prints out the Ampersand (@) and of course you know if I put a 1 or 2 It goes into the alphabet yes? There you go. Okay so what if I just wanted to print the 1 to the screen, you know? As I said, in the book a lot of the examples would be like "here you do this bit of math and then you get an answer of 3" you know, and it prints a C indicating that your value is 3. Okay, so why not do numbers? Because it's a slightly more complicated than it needs to be. Why? You know if mathematicians built a computer, well they didn't. It was electrical engineers you know if... not most Electronics whizzes aren't necessarily math whizzes, although mathematics was a prerequisite. I remember when I went to high school I had been building electronic circuits since I was like eight years old. and I was really looking forward to taking Electronics in high school. But they were like "No, you have to take algebra first" you know? So prerequisite. Didn't necessarily mean I was into math, you know. I was into Electronics right? Anyways I digress. 
So let's say I actually did want to print a numerical value to the screen. I could do that. Here let's look over here on the Commodore Screen Codes and there's all your alphabet values. And if I go down here to where the numbers start, You see 0 starts at 48 all the way to 9 at 57. So in theory then I could just take... Let me start at 0 here. I could take my 0 and just add 48 to it like that. Let me print that out.

And there's a 0. So instead of Ampersand, I put a 1 here.

Pretty good numerical output see? That works fine up until you get to 10 of course, you know? and then it goes off into symbols right? Yeah. So I get a colon now right? So let's say I'm just going to print all the numbers out using a loop real quick. So let me see to...

create my Loop let me see...

I have a loop here, and then I'm gonna have a Branch command down here. Like BEQ or BNE whatever. Back to Loop and that will climb. So I'm going to use a new command here: Increment. Like that, um no. It would be nice. If I could just call Increment and it would add 1 to the Accumulator. But it doesn't quite work that way. I could go, if I was using X, I'm sorry X. There. You know for X I can Increment the X register. I could also Increment the Y register. But doesn't work quite that way with the Accumulator unfortunately. That would be handy. So what I can do is, I'm going to take this value that I load into A and store it in a bit of memory here 2044. Okay then let me see, I can Increment 2044 right? Then once I've done that, load it back so I can read it. Load 2044 back into the Accumulator. Okay, and then having done that, I'm going to do a little Compare (CMP) to the value of 10. Okay, and then I'm going to introduce a new Branch command. And that is Branch on Carry Clear. Okay, so the way all these Branch commands work are for... let me go over to my book here. Every time you do a mathematical operation well not every time but under certain conditions Like if you go into the negative it will set a Flag. And the way Flags work, there's just a very small area of memory put aside called the Status Register. Here, status register. Okay and it's just 1 Byte, which as you recall, there are 8 Bits to a Byte. So if under certain conditions it will set one of these Bits. So it's essentially 8 Booleans. A Boolean being either 1 or 0. A value that indicates whether a condition is True or False.
Okay, so back to the book over here. Like if you do a mathematical calculation and the result is negative, it will set this first value to 1 there, and that tells it that it's negative. So when we've used our Branch commands in the past a Branch If Minus (BMI) What it does is it looks in the Status Register to see if this value is True. Or if the value's in the negative. Boolean has been set to a 1 right? You have different Flags. Overflow this one is unused, break, decimal, interrupt, zero indicating whether the mathematical calculation operation results in a 0 This will get set to a 1 or carry if presence of a carry or a borrow during arithmetic operations. So if you go over the 255 spaces or value that you can store in a Byte... Yeah, let's say you're at 1111 like that and you add one to that it will carry over. It'll flip back to zero for oops! There it'll flip back to 0 but it will also set the Carry Flag. Yeah. So that there is a way to check, in case you wanted to like do math with numbers larger than 255 and stuff, you know? So and all that's a little bit more complicated than it probably should be in modern computers. There's easier methods to deal with... or modern computer programming languages. 
Anyways, get back to our little program here. Let me just run this, see where I messed up.

Okay Colon. Because that is set to a 10. Let me set this back to a 0.

I'm getting the value 9. Okay. So what essentially has happened here: this is 0 had 1 added to it. Oh well put it in memory, grab that into the Accumulator here, and then, well I'm going to add 1 to the value you see? Here that's stored in memory. And then to look at it or to do the comparison we'll put it back in the Accumulator. Then do our comparison, okay? So what's going on here, as long as this comparison to 10 is less than 10. It will keep looping. It'll keep going back to here, and doing this over and over and over. And so we see the output 9 to the screen because once this value becomes 10, then this comparison no longer works, and then it exits out of the loop. Okay understandable. Now so maybe I I'd like to print out all 9 of those numerical values. So what's technically going on here

is the value that I'm writing to 1024. It writes a 0, then it writes a 1, then it writes a 2, and it overwrites each one until it gets to the last result of 9, and that's what you're seeing on the screen. To make that slightly more obvious, instead of using 1024, and that is a Screen Code, I'm going to use the the PETSCII code here. And that is JSR 65490 like that. And I should get the same result because as I said using the Screen Codes the numbers, numerical symbols begin at 48. But if I go over here to PETSCII codes and go down, even though the letter values, alphabet values are in a different place, the numerical values begin at the exact same place. At 48. So this bit of code works either way using PETSCII codes or the Screen Codes. So heading back here. If I run this...

There you see? It prints 0 1 2 3 4 5 all the way through 9, you know? Of course I could uh...

Here. Let's make this like 16 or something. So if you're only printing the value, a small value, say from 0 to 9 out, you can use this technique of adding 48 to the value. And you can get the numerical symbol and see the actual value of your calculation. But of course that only works from 0 to 9. After that you get other things you see? 
So there. I've introduced basically 3 new commands at one time here; the Branch on Clear Carry, talked a bit about the concept of Flags. The different types of flags. There's a negative flag, overflow, break, decimal, interrupt, zero flag, carry flag. Yeah and so if all of these are 0, all of these Booleans being stored in your Status Register, then the loop BCC will Branch to wherever. In this case we're branching back to a loop once the value gets set to a 1 here. It's no longer true and exits out. Okay so, and then I introduced Increment and as I said you can also INX Increment an X value. You can increment a Y value. But if I want to Increment what's... oops! Increment what's in the Accumulator, you know, then I had to go and store it in a bit of memory, and then Increment that bit of memory. Yeah, and then just to do the comparison, or print it on the screen, put it back into the Accumulator. And then it goes back and prints it out here in the form of a PETSCII code there.