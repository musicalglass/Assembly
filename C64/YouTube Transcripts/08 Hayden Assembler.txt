I have been drawing upon a wealth of computer books for the Commodore 64 which you can download for free at this address heah. And most of these are 35 plus years old. The book that I'm referring to mostly is here which is the newer version of this book and it came with some software. So if you want to follow along here you can download the PDF for free and also download the accompanying software that came with the book. Probably first thing you're thinking "Well why don't I just get a modern book and throw a bunch of money at it and it will be free of Errors?" [snickers] Yeah! That'll be the day! 
So basically you know, you read one programming book and it has some erroneous code and then you can go and compare that with another programming book and somewhere between the two you have your Rosetta Stone and can come up with some actual working code. 
So here I've got the PDF, and the book as I said came with a cassette that had all of the software on it. Way back in the old days a cassette was one method of storing data and you'd get this device here and you could load data off of the cassette onto your Commodore 64. The other option of course was the floppy disk drive. Let me go look at this here. There that's what a floppy looked like and they called them floppy because you could Bend this, It was like really soft plastic. Later of course they had the three inch floppies that you may be more familiar with. They still call them floppies although the three inch ones didn't flop. This was pretty soft and floppy about six inches or so. But I digress here.
I am going to then go to my C64 emulator and I've already downloaded the disk image that came with the book. And the way you load that is: You go attach the disk image to Virtual Drive 8, I'm going to use. And the book is published by Hayden, so it's called The Hayden Assembler here, and I'm going to load that and now it's in the computer's memory. So now to load it you go in quotations "$" and then tell it which drive to look on. 8 there. And that just takes a second and I can LIST what's on the virtual disk image. It's got a couple programs on there. We want this assembler here. So I am going to go load quotation C64 and you don't have to type all of this I can just add and asteri... whoops! SHIFT * and that says C64(anything). There. I'll go comma and tell it which virtual disk to look on, and load it. And now that will take a moment to load all of the code, you know.

♫ da dada
♫ dada da dada da 
♫ da dada
♫ da dada dada da

A little elevator music to keep your mind occupied, There there we go. It's all loaded. Now it says "Ready" so I can run the program and there we go. Press SPACE to continue. I'm going to keep this minimized so that I can still look at my code here in the background. Let me jump down to the first code example in the book. 
Here we go. So this assembler that came with the book uses its own kind of proprietary syntax. A little bit different than what we're using today on CBM studio and other assemblers. But we're just going to run with that shall we? Okay. So if I go here to Vice, (move it over so I can actually see the code a bit) it says "E to enter program"
I'm going to go E. It says start address. The book recommends 828 so I'm just gonna go by the book here. And then the question mark means go ahead and write the first line of code. This is LDX which we haven't actually covered yet. But I'm loading into the X register a value and it's actually LDXIM is the command in this book. Which would be LDX #value so the equivalent of this in a modern assembler is LDX #1.

Let's see so just let me translate here: (STX) Store what's in the X accumulator into... whoops! talking and trying to think at the same time, ...into 900.

LDAIM (Immediate Mode) that would be #2. (translates to LDA #2). And then ADD with CARRY the value stored in memory location 900. Then it says to store that in memory location 901. Well that's not real useful because nothing will happen when you run the program. Why don't we instead store that in 1024 and print it to the screen? We'll go RTS to return back to BASIC and then when you're done using this particular assembler you type END (ENTER) and it will exit, and you hit any key to go back to the main menu.
Now it says I could list my program 
L
Where is it? It's at 828 (ENTER) 
yada yada yada there it is!
I said maybe in an earlier tutorial that this program, or book, came with a disassembler. No, it actually doesn't disassemble, but it shows you the Dump (assembly dump) similar to what you see in CBM and there's the memory locations listed in both Decimal format and Hexadecimal for your convenience. 
Okay so there's the assembly code. We entered in the equivalent values in Hexadecimal that are stored into the computer's memory. Let me just hit any key to get out of there. It says to run program you hit R. Arrrr, and that is at 828, and it prints a value to the screen. 
Now this: In the glorious tradition of most programming books the very first bit of code that you run is erroneous! I added a 1 and a 2 together and it gave me a b c d which would be the value 4. So okay great! Again you look at one book and then you compare it to another book, you know, and then maybe you go on a forum and you post "Hey, how do you do this?" and they write back "Well, obviously you do not have enough education to understand the difference between signed and unsigned numbers mathematics..." You know, so a lot of help they are on the forums. :( 
But I happen to know what the problem is here. He did some mathematics and he did ADD with CARRY and didn't CLEAR the carry. So why don't we do this correctly? I'm just going to translate what I have found in the book. Very first thing I want to do is CLEAR the CARRY. Nyah!

L D X I M 1

Store X in memory location 900 L D X I M 2
and then ADD with CARRY the value that is stored in memory location 900.
Now, any math operation is going to end up in the Accumulator. So I mean here we could have just as easily done LDA 1, Store A in memory location there wouldn't really be any conflict because then we load A with a new number, you know. So whatever six or one half a dozen the other.
ADC 
then he tells you to store that to an arbitrary memory location which is of course useless because it doesn't do anything. We will go RTS to end the program and then type END to get out of the assembler. Press any key to continue. I didn't press it hard enough apparently. There we go. Run the program is "R". Type memory location that you stored it in and there. There is your correct answer. So there you go. You know, you can go out and throw $39.95 at a brand new book and guess what it will be: as erroneous as books written 40 years ago believe it or not, you know. So everything is with a grain of salt. That's kind of why I'm doing these videos. I mean, you can download all kinds of free programming books. No guarantee that any of them are going to be 100% error free ever! You know. So here I am making videos. I do... 
I have a bit of astigmatism so it's actually irritating for me to read books anymore. You know? So I do prefer videos and concise explanations, So that is why I'm kind of posting videos of everything that I'm learning, kind of as I'm learning it. I make no 
claim that I'm any kind of expert in Assembly. I'm just going along kind of learning this and that and documenting everything as I learn it. And then maybe a year or two down the line if I want to go back and do some more assembly in the C64 I have my own video tutorial. So this is just as much for my own edification as perhaps yours. I hope these video tutorials are useful to you as well. 
Thank you.