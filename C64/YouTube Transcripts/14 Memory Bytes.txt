In the previous video I made a pretty dumb mistake. You know, where I changed the address of the program and didn't update the Local Jump commands and it didn't work, you know. And I'm sitting there scratching my head and... Something that was painfully obvious possibly to you the viewer. And now I could be egotistical about that and just go back and redo the video so it's perfect. But in many ways I I think it's probably more beneficial to just leave those mistakes in the videos and then demonstrate how to troubleshoot and recover from your mistakes. Yeah. Oh this was not really troubleshooting it's like... but yeah. So that way you learn a little better hopefully. I'm sure if you've done any programming before, everybody goes out and you get a book on programming. And it starts out simple enough you know? "Oh here's how to do a variable". Okay. "Here's how to do a For Loop". Okay. "Here's how to do an Array". Okay. And then it's like "Okay now that you know everything about programming here is a 10 page all-in-wonder program kitchen sink that does everything. Go forth and create!" You know? And I don't know about you but maybe you have sat there and typed in some 10 page long program and then you try to run it and it just doesn't work, right? and you're left sitting there staring at the screen dumbfounded. Wondering "Is it something I did, or is it something the author did?" You don't know! You have no... the the author of the book hasn't taken the time to show you how to troubleshoot your own programs! And it might just be an error on the part of the typesetter, who input the info to make the book. But yeah, I've gotten books on programming and it gets to the point where you get this big program you type it and it doesn't work. And then of course the author assumes that it worked just fine and proceeds on to more and more lessons that build upon that huge program. And two-thirds of the book is useless to you now. Right. So that's it's probably a good thing for me to just go ahead and include my mistakes in my videos. Enough talk about making mistakes. 
So the book continues on a little further. This is a very interesting bit here um Chapter 2 Verse 3, where he talks about how much memory each of the commands use up. Okay, let me just go over here and look at the dump for a second. There. So here you can see Load Accumulator is using 2 bytes of memory and the Jump command is using 3 bytes of memory. RTS, only 1 byte. You see? And this can be a critical thing to know in certain instances. We go back to like the early days of computers. And you may have seen an old movie, where the guy walks into a room and there is a huge monstrosity of a computer that takes up the entire room, and he's like "This computer uses an entire megabyte of memory!" and they're like "Oooooh!" Haha. You know by today's standards that's laughable you know we have computers with gigabytes of RAM and such. Or if you've seen Apollo 13. You know where everything breaks down and they have to reboot their computer and reprogram it? Keep in mind when you're sending anything into space a few extra ounces may mean 10 gallons more of fuel and then you have to make the engine, the ship itself even bigger so we can get the extra 10 gallons of fuel off and it's exponential. So a bean counter can be very useful there you know when you have to build an extremely lightweight computer to go into space and it has a minimal amount of memory and you have to optimize every little byte. And then of course today we've gone full circle. Now where you have These ARM processors for instance, or your Raspberry Pi, or your Gumstick computers that today could literally fit on your finger now. So we've kind of come full circle there in that in certain instances counting every byte of memory can be critical. Also for speed if you want to write a program that runs faster. Even programmers that are writing in C++ or whatever will oftentimes write some bits of their code in assembly because it's faster. It'll run faster. And so there you'll be on the forums and someone will post a bit of code and some old school programmer will chime in "You know you could have done that line there using two bytes less memory if you'd done it this way" and you know and and of course you know, maybe you buy a new computer and it works great. But then over time it keeps getting slower and slower because these dumb programmers just think that their program is the only thing that you're going to be running on your computer. I swear to God! You know? And they just use up memory like there's no tomorrow declaring the wrong kind of variables and uh throwing in some huge all in wonder bit of code to do some simple little thing that they grabbed off of sourceforge or whatever. And your computer gets slower and slower until you have to get a new computer and same story! It runs fine for a while and then it's starts slowing down because these programmers are one jump ahead of you. They got the latest computer packed with as much RAM as possible and they're just using it up frivolously. Why? Because they don't understand this! So that's why learning a bit more about Assembly and what's really going on under the hood in your computer can really help you to become a more efficient programmer regardless of what programming language you're, So enough talk on the topic of memory I will get on to some further lessons.